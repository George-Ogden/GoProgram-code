class Convoluting extends Neural_Network{constructor(t,e,s,o=3,l="swish",r=.001){super("Convoluting",l,r),this.length=s,this.width=t,this.height=e,this.colours=o,this.kernels=[],this.kernel_deltas=[];for(let o=0;o<this.colours;o++){this.kernels.push([]),this.kernel_deltas.push([]);for(let l=0;l<s;l++)this.kernels[o].push(Matrix.multiply(new Matrix(e,t),2/t**2)),this.kernel_deltas[o].push(Matrix.blank(e,t))}}static convolution(t,e){let s=new Matrix(t.rows-e.rows+1,t.cols-e.cols+1);for(let o=0;o<s.rows;o++)for(let l=0;l<s.cols;l++)s.data[o][l]=Matrix.multiply(t.subsection(l,o,e.cols,e.rows),e).sum();return s}static full_convolution(t,e){return t.pad(e.rows-1,e.cols-1),Convoluting.convolution(t,Matrix.flip(e))}forward_propagate(t){let e=[];this.process=[];for(let s=0;s<this.colours;s++){e.push(t[s].copy()),this.process.push([]);for(let t=0;t<this.length;t++)this.process[s].push(e[s].copy()),e[s].set(Matrix.map(Convoluting.convolution(e[s],this.kernels[s][t]),this.activation_function.function))}return e}backward_propagate(t){for(let e=this.length-1;e>=0;e--)for(let s=0;s<this.colours;s++){let o=Matrix.map(this.process[s][e],this.activation_function.derivative);o=Convoluting.convolution(o,t[s]),t[s]=Convoluting.full_convolution(t[s],this.kernels[s][e]),this.kernel_deltas[s][e].add(o)}return t}update(){for(let t=0;t<this.colours;t++)for(let e=0;e<this.length;e++)this.kernels[t][e].add(Matrix.multiply(this.kernel_deltas[t][e],this.learning_rate),.25,this.kernels[t][e]),this.kernel_deltas[t][e].reset()}show(){for(let t=0;t<this.colours;t++)for(let e=0;e<this.length;e++)this.kernels[t][e].show()}static from_string(t){let e=new Convoluting(t.width,t.height,t.length,t.colours,t.activation_function_name);e.learning_rate=t.learning_rate;for(let s=0;s<e.colours;s++)for(let o=0;o<e.length;o++)e.kernels[s][o]=Matrix.fromArray(t.kernels[s][o].data);return e}export(){let t=this.copy();return delete t.process,delete t.activation_function,delete t.process,delete t.kernel_deltas,JSON.stringify(t)}}