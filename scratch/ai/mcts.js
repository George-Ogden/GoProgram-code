EPS=1e-8;class MCTS{constructor(s,t,i){this.game=s,this.nnet=t,this.args=i,this.Qsa={},this.Nsa={},this.Ns={},this.Ps={},this.Es={},this.Vs={}}async getActionProb(s){for(let t=0;t<this.args.numMCTSSims;t++)this.search(s),await new Promise(s=>setTimeout(s,1));let i=this.game.stringRepresentation(s),h=[];for(let e=0;e<this.game.getActionSize();e++)h.push(this.Nsa.hasOwnProperty([i,e])?this.Nsa[[i,e]]:0);let a=h.reduce((s,t,i,e)=>t==Math.max(...h)?s.concat(i):s,[]),r=a[Math.floor(Math.random()*a.length)],n=Array(h.length).fill(0);return n[r]=1,n}search(s){let t=this.game.stringRepresentation(s);if(this.Es.hasOwnProperty(t)||(this.Es[t]=this.game.getGameEnded(s,1)),0!=this.Es[t])return-this.Es[t];if(!this.Ps.hasOwnProperty(t)){let i=this.game.predict(this.nnet,s);this.Ps[t]=i[0].arraySync()[0];let h=i[1].arraySync()[0][0],e=this.game.getValidMoves(s,1);this.Ps[t]=this.Ps[t].map((s,t)=>e[t]?s:0);let a=this.Ps[t].reduce((s,t)=>s+t);return a>0&&(this.Ps[t]=this.Ps[t].map(s=>s/a)),this.Vs[t]=e,this.Ns[t]=0,-h}let r=this.Vs[t],n=Number.NEGATIVE_INFINITY,g=-1;for(let o=0;o<this.game.getActionSize();o++)if(r[o]){let c;(c=this.Qsa.hasOwnProperty([t,o])?this.Qsa[[t,o]]+this.args.cpuct*this.Ps[t][o]*Math.sqrt(this.Ns[t])/(1+this.Nsa[[t,o]]):this.args.cpuct*this.Ps[t][o]*Math.sqrt(this.Ns[t]+EPS))>n&&(n=c,g=o)}let l=g,m,N;[m,N]=this.game.getNextState(s,1,l),m=this.game.getCanonicalForm(m,N);let P=this.search(m);return this.Qsa.hasOwnProperty([t,l])?(this.Qsa[[t,l]]=(this.Nsa[[t,l]]*this.Qsa[[t,l]]+P)/(this.Nsa[[t,l]]+1),this.Nsa[[t,l]]++):(this.Qsa[[t,l]]=P,this.Nsa[[t,l]]=1),this.Ns[t]++,-P}}