class Convoluting extends Neural_Network{constructor(t,s,e,o=3,l="swish",r=.001){super("Convoluting",l,r),this.length=e,this.width=t,this.height=s,this.colours=o,this.kernels=[],this.kernel_deltas=[];for(let o=0;o<this.colours;o++){this.kernels.push([]),this.kernel_deltas.push([]);for(let l=0;l<e;l++)this.kernels[o].push(Matrix.multiply(new Matrix(s,t),2/t**2)),this.kernel_deltas[o].push(Matrix.blank(s,t))}}static convolution(t,s){let e=new Matrix(t.rows-s.rows+1,t.cols-s.cols+1);for(let o=0;o<e.rows;o++)for(let l=0;l<e.cols;l++)e.data[o][l]=Matrix.multiply(t.subsection(l,o,s.cols,s.rows),s).sum();return e}static full_convolution(t,s){return t.pad(s.rows-1,s.cols-1),Convoluting.convolution(t,Matrix.flip(s))}forward_propagate(t){let s=[];this.process=[];for(let e=0;e<this.colours;e++){s.push(t[e].copy()),this.process.push([]);for(let t=0;t<this.length;t++)this.process[e].push(s[e].copy()),s[e].set(Matrix.map(Convoluting.convolution(s[e],this.kernels[e][t]),this.activation_function.function))}return s}backward_propagate(t){for(let s=this.length-1;s>=0;s--)for(let e=0;e<this.colours;e++){let o=Matrix.map(this.process[e][s],this.activation_function.derivative);o=Convoluting.convolution(o,t[e]),t[e]=Convoluting.full_convolution(t[e],this.kernels[e][s]),this.kernel_deltas[e][s].add(o)}return t}update(){for(let t=0;t<this.colours;t++)for(let s=0;s<this.length;s++)this.kernels[t][s].add(Matrix.clip(Matrix.multiply(this.kernel_deltas[t][s],this.learning_rate),.25,this.kernels[t][s])),this.kernel_deltas[t][s].reset()}show(){for(let t=0;t<this.colours;t++)for(let s=0;s<this.length;s++)this.kernels[t][s].show()}static from_string(t){let s=new Convoluting(t.width,t.height,t.length,t.colours,t.activation_function_name);s.learning_rate=t.learning_rate;for(let e=0;e<s.colours;e++)for(let o=0;o<s.length;o++)s.kernels[e][o]=Matrix.fromArray(t.kernels[e][o].data);return s}}