class Fully_Connected_Network extends Neural_Network{constructor(t,i,s,e,h,a=.1){super("Fully_Connected_Network",h,a),this.length=i+2,this.width=s,this.weights=[],this.biases=[],this.weight_deltas=[],this.bias_deltas=[];for(let t=0;t<this.length;t++)this.weights.push(Matrix.multiply(new Matrix(this.width,this.width),Math.sqrt(2/this.width))),this.biases.push(Matrix.multiply(new Matrix(1,this.width),Math.sqrt(2/this.width))),this.weight_deltas.push(Matrix.blank(this.weights[t].rows,this.weights[t].cols)),this.bias_deltas.push(Matrix.blank(1,this.biases[t].cols));this.weights[0]=Matrix.multiply(new Matrix(t,this.width),Math.sqrt(2/this.width)),this.weight_deltas[0]=Matrix.blank(t,this.width),this.weights[this.length-1]=Matrix.multiply(new Matrix(this.width,e),Math.sqrt(2/this.width)),this.weight_deltas[this.length-1]=Matrix.blank(this.width,e),this.biases[this.length-1]=Matrix.multiply(new Matrix(1,e),Math.sqrt(4/e)),this.bias_deltas[this.length-1]=Matrix.blank(1,e)}copy(){return eval(this.type).from_string(this)}show(){for(let t=0;t<this.length;t++)this.weights[t].show(),this.biases[t].show()}forward_propagate(t){let i=t.copy();this.process=[i.copy()];for(let t=0;t<this.length;t++)i.dot(this.weights[t]),i.add(this.biases[t]),i.map(this.activation_function.function),this.process.push(i.copy());return i}backward_propagate(t){for(let i=this.length-1;i>=0;i--){let s=Matrix.map(this.process[i+1],this.activation_function.derivative);s.multiply(t),t.dot(Matrix.transpose(this.weights[i])),this.bias_deltas[i].add(s),this.weight_deltas[i].add(Matrix.dot(Matrix.transpose(this.process[i]),s))}return t}update(){for(let t=0;t<this.length;t++)this.weights[t].add(Matrix.clip(Matrix.multiply(this.weight_deltas[t],this.learning_rate),.25,this.weights[t])),this.biases[t].add(Matrix.clip(Matrix.multiply(this.bias_deltas[t],this.learning_rate),.25,this.biases[t])),this.weight_deltas[t].reset(),this.bias_deltas[t].reset()}train(t,i=1,s=t.length){let e=Math.floor(Math.random()*t.length);for(let h=e;h<i*s+e;h++){for(let i=0;i<s;i++){let s=Matrix.subtract(t[(h+i)%t.length][1],this.forward_propagate(t[(h+i)%t.length][0]));this.backward_propagate(s)}this.update()}}export(){let t=this.copy();return delete t.process,delete t.bias_deltas,delete t.weight_deltas,delete t.activation_function,JSON.stringify(t)}static from_string(t){let i=new Fully_Connected_Network(t.weights[0].rows,t.length-2,t.weights[0].cols,t.weights[t.weights.length-1].cols,t.activation_function_name,t.learning_rate);for(let s=0;s<i.length;s++)i.weights[s]=Matrix.fromArray(t.weights[s].data),i.biases[s]=Matrix.fromArray(t.biases[s].data);return i}}