class Player{constructor(t,r=1/0){this.umpire=t,this.max_depth=r}async move(t,r){let a=Matrix.blank(t.rows,t.cols);if(t.equals(Matrix.blank(t.rows,t.cols)))a.data[t.cols-1][(t.rows-1)/2]=r;else{let e=await this.check(Matrix.multiply(t,r),1,1);e=Object.keys(e).reduce((t,r)=>e[t]>e[r]?t:r,0),a.data[e%t.rows][Math.floor(e/t.rows)]=r}return a}async check(t,r,a){let e;if(await new Promise(t=>setTimeout(t,0)),0!=(e=this.umpire.check_state(t)))return e;if(a>this.max_depth)return this.evaluate(t);if(t.rss()==t.rows*t.cols)return 0;if(1==r){let r={};for(let a=0;a<t.rows*t.cols;a++){let e=t.copy();0==e.data[a%t.rows][Math.floor(a/t.rows)]&&(e.data[a%t.rows][Math.floor(a/t.rows)]=1,r[a]=e)}this.mirror(r);let e={},s=-1;for(let t in r)if(e[t]=await this.check(r[t],-1,a+1),1==(s=Math.max(s,e[t])))break;return 1==a?e:s}{let r={};for(let a=0;a<t.rows*t.cols;a++){let e=t.copy();0==e.data[a%t.rows][Math.floor(a/t.rows)]&&(e.data[a%t.rows][Math.floor(a/t.rows)]=-1,r[a]=e)}this.mirror(r);let e={},s=1;for(let t in r)if(e[t]=await this.check(r[t],1,a+1),-1==(s=Math.min(s,e[t])))break;return 1==a?e:s}}mirror(t){for(let r in t)for(let a in t)null!=t[r]&&null!=t[a]&&r!=a&&(t[r].equals(Matrix.flip(t[a],1,0))||t[r].equals(Matrix.flip(t[a],0))||t[r].equals(Matrix.flip(t[a]))||Matrix.transpose(t[r]).equals(t[a])||Matrix.transpose(t[r]).equals(Matrix.flip(t[a],1,0))||Matrix.transpose(t[r]).equals(Matrix.flip(t[a],0))||Matrix.transpose(t[r]).equals(Matrix.flip(t[a])))&&delete t[r]}evaluate(){return Math.random()}}