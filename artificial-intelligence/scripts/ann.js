class Neural_Network{constructor(t,i,s,e,r){this.length=i+2,this.width=s,this.weights=[];for(let t=0;t<this.length;t++)this.weights.push(new Matrix(this.width,this.width));this.weights[0]=new Matrix(t,this.width),this.weights[this.length-1]=new Matrix(this.width,e),this.biases=[];for(let t=0;t<this.length;t++)this.biases.push(new Matrix(1,this.width));this.biases[this.length-1]=new Matrix(1,e),this.activation_function_name=r,this.activation_function=activation_functions[r],this.learning_rate=.1}show(){for(let t=0;t<this.length;t++)this.weights[t].show(),this.biases[t].show()}feedforward(t){let i=Matrix.fromArray([t]);this.process=[i.copy()];for(let t=0;t<this.length;t++)i.dot(this.weights[t]),i.add(this.biases[t]),i.map(this.activation_function.function),this.process.push(i.copy());return i.data[0]}train(t,i=1){for(let s=0;s<i;s++){let i=Math.floor(Math.random()*t.length),s=Matrix.subtract(Matrix.fromArray([t[i][1]]),Matrix.fromArray([this.feedforward(t[i][0])]));for(let t=this.length-1;t>=0;t--){let i=Matrix.map(this.process[t+1],this.activation_function.derivative);i.multiply(s),i.multiply(this.learning_rate),s.dot(Matrix.transpose(this.weights[t])),this.biases[t].add(i),this.weights[t].add(Matrix.dot(Matrix.transpose(this.process[t]),i))}}}cost(t){let i=0;for(let s=0;s<t.length;s++)i+=Matrix.subtract(Matrix.fromArray([t[s][1]]),Matrix.fromArray([this.feedforward(t[s][0])])).rss();return i/t.length}static from_string(t){let i=new Neural_Network(t.weights[0].rows,t.length-2,t.weights[0].cols,t.weights[t.weights.length-1].cols,t.activation_function_name);i.process=t.process,i.weights=t.weights,i.biases=t.biases;for(let t=0;t<i.length;t++)i.weights[t]=Matrix.fromArray(i.weights[t].data),i.biases[t]=Matrix.fromArray(i.biases[t].data);return i}}