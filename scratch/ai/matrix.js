class Matrix{constructor(t=0,s=0){this.data=[],this.rows=t,this.cols=s;for(let r=0;r<t;r++){this.data.push([]);for(let a=0;a<s;a++)this.data[r].push(1)}this.randomise()}static blank(t,s,r=0){let a=new Matrix(t,s);return a.reset(r),a}static fromArray(t){let s=new Matrix(t.length,t[0].length);return s.data=t,s}set(t){t=Matrix.fromArray(t.data),this.rows=t.rows,this.cols=t.cols,this.data=t.data}show(){return console.table(this.data),this.data}map(t,s=null){if(s){let r=new Matrix(this.rows,this.cols);for(let a=0;a<this.rows;a++)for(let e=0;e<this.cols;e++)r.data[a][e]=t(this.data[a][e],s.data[a][e]);return r}for(let i=0;i<this.rows;i++)for(let o=0;o<this.cols;o++)this.data[i][o]=t(this.data[i][o])}static map(t,s){let r=t.copy();return r.map(s),r}randomise(){this.map(t=>2*Math.random()-1)}reset(t=0){this.map(()=>t)}transpose(){this.set(Matrix.transpose(this))}static transpose(t){let s=new Matrix(t.cols,t.rows);for(let r=0;r<t.rows;r++)for(let a=0;a<t.cols;a++)s.data[a][r]=t.data[r][a];return s}static add(t,s){return t.map((t,s)=>t+s,s)}add(t){this.set(Matrix.add(this,t))}static subtract(t,s){return t.map((t,s)=>t-s,s)}subtract(t){this.set(Matrix.subtract(this,t))}multiply(t){"number"==typeof t?this.map(s=>s*t):this.set(this.map((t,s)=>t*s,t))}static multiply(t,s){let r=t.copy();return r.multiply(s),r}static dot(t,s){if(t.cols=s.rows){let r=new Matrix(t.rows,s.cols);for(let a=0;a<r.rows;a++)for(let e=0;e<r.cols;e++){let i=0;for(let o=0;o<t.cols;o++)i+=t.data[a][o]*s.data[o][e];r.data[a][e]=i}return r}}dot(t){this.set(Matrix.dot(this,t))}clip(t,s=Matrix.blank(this.rows,this.cols,1)){this.set(this.map((s,r)=>Math.abs(s)>Math.abs(r*t)?s>0?Math.abs(r*t):-Math.abs(r*t):s,s))}static clip(t,s,r=Matrix.blank(this.rows,this.cols,1)){let a=t.copy();return a.clip(s,r),a}rss(){return this.data.reduce((t,s)=>t+s.reduce((t,s)=>t+s*s,0),0)}subsection(t,s,r,a){let e=new Matrix(a,r);for(let i=s;i<s+a;i++)for(let o=t;o<t+r;o++)e.data[i-s][o-t]=this.data[i][o];return e}copy(){return Matrix.fromArray(eval(JSON.stringify(this.data)))}static pad(t,s=1,r=1){let a=new Matrix(t.rows+2*s,t.cols+2*r);a.reset();for(let e=0;e<t.rows;e++)for(let i=0;i<t.cols;i++)a.data[e+s][i+r]=t.data[e][i];return a}pad(t=1,s=1){this.set(Matrix.pad(this,t,s))}static flip(t,s=!0,r=!0){let a=new Matrix(t.rows,t.cols);for(let e=0;e<t.rows;e++)for(let i=0;i<t.cols;i++)a.data[e][i]=t.data[r?t.rows-e-1:e][s?t.cols-i-1:i];return a}flip(t=!0,s=!0){this.set(Matrix.flip(this,t,s))}sum(){return this.data.reduce((t,s)=>t+s.reduce((t,s)=>t+s,0),0)}abs_sum(){return this.data.reduce((t,s)=>t+s.reduce((t,s)=>t+Math.abs(s),0),0)}static flatten(t){let s=new Matrix(1,t.rows*t.cols);for(let r=0;r<t.rows;r++)for(let a=0;a<t.cols;a++)s.data[0][r*t.cols+a]=t.data[r][a];return s}flatten(){this.set(Matrix.flatten(this))}static resize(t,s,r){let a=new Matrix(s,r);for(let e=0;e<s;e++)for(let i=0;i<r;i++)a.data[e][i]=t.data[parseInt((e*r+i)/t.cols)][(e*r+i)%t.cols];return a}resize(t,s,r){this.set(Matrix.resize(this,s,r))}subsection(t,s,r=this.cols,a=this.rows){let e=new Matrix(a,r);for(let i=s;i<s+a;i++)for(let o=t;o<t+r;o++)e.data[i-s][o-t]=this.data[i][o];return e}static build(t,s,r){let a=new Matrix(s,r);for(let e=0;e<s;e++)for(let i=0;i<r;i++)a.data[e][i]=t.data[0][e*r+i];return a}build(t,s){this.set(Matrix.build(this,t,s))}copy(){return Matrix.fromArray(eval(JSON.stringify(this.data)))}max(){return this.data.reduce((t,s)=>Math.max(t,s.reduce((t,s)=>Math.max(t,s))),-1/0)}find(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.cols;r++)if(this.data[s][r]==t)return[s,r]}max_plot(){let t=new Matrix(this.rows,this.cols),s=this.max();return t.reset(),t.data[this.find(s)[0]][this.find(s)[1]]=1,t}static insert(t,s,r,a){let e=t.copy();for(let i=0;i<s.rows;i++)for(let o=0;o<s.cols;o++)e.data[i+a][o+r]=s.data[i][o];return e}insert(t,s,r){this.set(Matrix.insert(this,t,s,r))}equals(t){return this.rows==t.rows&&this.cols==t.cols&&this.data.reduce((s,r,a)=>s?r.reduce((s,r,e)=>s?r==t.data[a][e]:0,1):0,1)}static concat(t,s){let r=new Matrix(t.rows,t.cols+s.cols);return r.insert(t,0,0),r.insert(s,t.cols,0),r}concat(t){this.set(Matrix.concat(this,t))}static split(t,s){return[t.subsection(0,0,s),t.subsection(s,0,t.cols-s)]}}